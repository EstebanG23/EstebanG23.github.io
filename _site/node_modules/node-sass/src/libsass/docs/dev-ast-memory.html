<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>LibSass smart pointer implementation | estebang23.github.io</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="LibSass smart pointer implementation" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/node_modules/node-sass/src/libsass/docs/dev-ast-memory.html" />
<meta property="og:url" content="http://localhost:4000/node_modules/node-sass/src/libsass/docs/dev-ast-memory.html" />
<meta property="og:site_name" content="estebang23.github.io" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/node_modules/node-sass/src/libsass/docs/dev-ast-memory.html","headline":"LibSass smart pointer implementation","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=08194154e5c3f87742365edb210c0599bab19902">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">estebang23.github.io</a></h1>
      

      <h1 id="libsass-smart-pointer-implementation">LibSass smart pointer implementation</h1>

<p>LibSass uses smart pointers very similar to <code class="highlighter-rouge">shared_ptr</code> known
by Boost or C++11. Implementation is a bit less modular since
it was not needed. Various compile time debug options are
available if you need to debug memory life-cycles.</p>

<h2 id="memory-classes">Memory Classes</h2>

<h3 id="sharedobj">SharedObj</h3>

<p>Base class for the actual node implementations. This ensures
that every object has a reference counter and other values.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AST_Node</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SharedObj</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div></div>

<h3 id="sharedptr-base-class-for-sharedimpl">SharedPtr (base class for SharedImpl)</h3>

<p>Base class that holds on to the pointer. The reference counter
is stored inside the pointer object directly (<code class="highlighter-rouge">SharedObj</code>).</p>

<h3 id="sharedimpl-inherits-from-sharedptr">SharedImpl (inherits from SharedPtr)</h3>

<p>This is the main base class for objects you use in your code. It
will make sure that the memory it points at will be deleted once
all copies to the same object/memory go out of scope.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span><span class="o">*</span> <span class="n">pointer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Class</span><span class="p">(...);</span>
<span class="n">SharedImpl</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span>
</code></pre></div></div>

<p>To spare the developer of typing the templated class every time,
we created typedefs for each available AST Node specialization.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">SharedImpl</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">Number_Obj</span><span class="p">;</span>
<span class="n">Number_Obj</span> <span class="n">number</span> <span class="o">=</span> <span class="n">SASS_MEMORY_NEW</span><span class="p">(...);</span>
</code></pre></div></div>

<h2 id="memory-life-cycles">Memory life-cycles</h2>

<h3 id="pointer-pickups">Pointer pickups</h3>

<p>I often use the terminology of “pickup”. This means the moment when
a raw pointer not under any control is assigned to a reference counted
object (<code class="highlighter-rouge">XYZ_Obj = XYZ_Ptr</code>). From that point on memory will be
automatically released once the object goes out of scope (but only
if the reference counter reaches zero). Main point beeing, you don’t
have to worry about memory management yourself.</p>

<h3 id="object-detach">Object detach</h3>

<p>Sometimes we can’t return reference counted objects directly (see
invalid covariant return types problems below). But we often still
need to use reference objects inside a function to avoid leaks when
something throws. For this you can use <code class="highlighter-rouge">detach</code>, which basically
detaches the pointer memory from the reference counted object. So
when the reference counted object goes out of scope, it will not
free the attached memory. You are now again in charge of freeing
the memory (just assign it to a reference counted object again).</p>

<h2 id="circular-references">Circular references</h2>

<p>Reference counted memory implementations are prone to circular references.
This can be addressed by using a multi generation garbage collector. But
for our use-case that seems overkill. There is no way so far for users
(sass code) to create circular references. Therefore we can code around
this possible issue. But developers should be aware of this limitation.</p>

<p>There are AFAIR two places where circular references could happen. One is
the <code class="highlighter-rouge">sources</code> member on every <code class="highlighter-rouge">Selector</code>. The other one can happen in the
extend code (Node handling). The easy way to avoid this is to only assign
complete object clones to these members. If you know the objects lifetime
is longer than the reference you create, you can also just store the raw
pointer. Once needed this could be solved with weak pointers.</p>

<h2 id="addressing-the-invalid-covariant-return-types-problems">Addressing the invalid covariant return types problems</h2>

<p>If you are not familiar with the mentioned problem, you may want
to read up on covariant return types and virtual functions, i.e.</p>

<ul>
  <li>http://stackoverflow.com/questions/6924754/return-type-covariance-with-smart-pointers</li>
  <li>http://stackoverflow.com/questions/196733/how-can-i-use-covariant-return-types-with-smart-pointers</li>
  <li>http://stackoverflow.com/questions/2687790/how-to-accomplish-covariant-return-types-when-returning-a-shared-ptr</li>
</ul>

<p>We hit this issue at least with the CRTP visitor pattern (eval, expand,
listize and so forth). This means we cannot return reference counted
objects directly. We are forced to return raw pointers or we would need
to have a lot of explicit and expensive upcasts by callers/consumers.</p>

<h3 id="simple-functions-that-allocate-new-ast-nodes">Simple functions that allocate new AST Nodes</h3>

<p>In the parser step we often create new objects and can just return a
unique pointer (meaning ownership clearly shifts back to the caller).
The caller/consumer is responsible that the memory is freed.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">Number</span><span class="o">*</span> <span class="n">Number_Ptr</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">parse_integer</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span> <span class="c1">// do the parsing
</span>  <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Number_Ptr</span> <span class="nf">parse_number</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Number_Ptr</span> <span class="n">p_nr</span> <span class="o">=</span> <span class="n">SASS_MEMORY_NEW</span><span class="p">(...);</span>
  <span class="n">p_nr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(</span><span class="n">parse_integer</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">p_nr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Number_Obj</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">parse_number</span><span class="p">();</span>
</code></pre></div></div>

<p>The above would be the encouraged pattern for such simple cases.</p>

<h3 id="allocate-new-ast-nodes-in-functions-that-can-throw">Allocate new AST Nodes in functions that can throw</h3>

<p>There is a major caveat with the previous example, considering this
more real-life implementation that throws an error. The throw may
happen deep down in another function. Holding raw pointers that
we need to free would leak in this case.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">parse_integer</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span> <span class="c1">// do the parsing
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this <code class="highlighter-rouge">parse_integer</code> function the previous example would leak memory.
I guess it is pretty obvious, as the allocated memory will not be freed,
as it was never assigned to a SharedObj value. Therefore the above code
would better be written as:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">Number</span><span class="o">*</span> <span class="n">Number_Ptr</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">parse_integer</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span> <span class="c1">// do the parsing
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// this leaks due to pointer return
// should return Number_Obj instead
// though not possible for virtuals!
</span><span class="n">Number_Ptr</span> <span class="nf">parse_number</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Number_Obj</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">SASS_MEMORY_NEW</span><span class="p">(...);</span>
  <span class="n">nr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(</span><span class="n">parse_integer</span><span class="p">());</span> <span class="c1">// throws
</span>  <span class="k">return</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">;</span> <span class="c1">// Ptr from Obj
</span><span class="p">}</span>
<span class="n">Number_Obj</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">parse_number</span><span class="p">();</span>
<span class="c1">// will now be freed automatically
</span></code></pre></div></div>

<p>The example above unfortunately will not work as is, since we return a
<code class="highlighter-rouge">Number_Ptr</code> from that function. Therefore the object allocated inside
the function is already gone when it is picked up again by the caller.
The easy fix for the given simplified use case would be to change the
return type of <code class="highlighter-rouge">parse_number</code> to <code class="highlighter-rouge">Number_Obj</code>. Indeed we do it exactly
this way in the parser. But as stated above, this will not work for
virtual functions due to invalid covariant return types!</p>

<h3 id="return-managed-objects-from-virtual-functions">Return managed objects from virtual functions</h3>

<p>The easy fix would be to just create a new copy on the heap and return
that. But this seems like a very inelegant solution to this problem. I
mean why can’t we just tell the object to treat it like a newly allocated
object? And indeed we can. I’ve added a <code class="highlighter-rouge">detach</code> method that will tell
the object to survive deallocation until the next pickup. This means
that it will leak if it is not picked up by consumer.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">Number</span><span class="o">*</span> <span class="n">Number_Ptr</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">parse_integer</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span> <span class="c1">// do the parsing
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Number_Ptr</span> <span class="nf">parse_number</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Number_Obj</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">SASS_MEMORY_NEW</span><span class="p">(...);</span>
  <span class="n">nr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(</span><span class="n">parse_integer</span><span class="p">());</span> <span class="c1">// throws
</span>  <span class="k">return</span> <span class="n">nr</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">Number_Obj</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">parse_number</span><span class="p">();</span>
<span class="c1">// will now be freed automatically
</span></code></pre></div></div>

<h2 id="compile-time-debug-options">Compile time debug options</h2>

<p>To enable memory debugging you need to define <code class="highlighter-rouge">DEBUG_SHARED_PTR</code>.
This can i.e. be done in <code class="highlighter-rouge">include/sass/base.h</code></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">define</span> <span class="n">DEBUG_SHARED_PTR</span>
</code></pre></div></div>

<p>This will print lost memory on exit to stderr. You can also use
<code class="highlighter-rouge">setDbg(true)</code> on sepecific variables to emit reference counter
increase, decrease and other events.</p>

<h2 id="why-reinvent-the-wheel-when-there-is-shared_ptr-from-c11">Why reinvent the wheel when there is <code class="highlighter-rouge">shared_ptr</code> from C++11</h2>

<p>First, implementing a smart pointer class is not really that hard. It
was indeed also a learning experience for myself. But there are more
profound advantages:</p>

<ul>
  <li>Better GCC 4.4 compatibility (which most code still has OOTB)</li>
  <li>Not thread safe (give us some free performance on some compiler)</li>
  <li>Beeing able to track memory allocations for debugging purposes</li>
  <li>Adding additional features if needed (as seen in <code class="highlighter-rouge">detach</code>)</li>
  <li>Optional: optimized weak pointer implementation possible</li>
</ul>

<h3 id="thread-safety">Thread Safety</h3>

<p>As said above, this is not thread safe currently. But we don’t need
this ATM anyway. And I guess we probably never will share AST Nodes
across different threads.</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
