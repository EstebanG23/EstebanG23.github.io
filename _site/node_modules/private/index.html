<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>private | estebang23.github.io</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="private" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/node_modules/private/" />
<meta property="og:url" content="http://localhost:4000/node_modules/private/" />
<meta property="og:site_name" content="estebang23.github.io" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/node_modules/private/","headline":"private","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=08194154e5c3f87742365edb210c0599bab19902">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">estebang23.github.io</a></h1>
      

      <h1 id="private--">private <a href="https://travis-ci.org/benjamn/private"><img src="https://travis-ci.org/benjamn/private.png?branch=master" alt="Build Status" /></a> <a href="https://greenkeeper.io/"><img src="https://badges.greenkeeper.io/benjamn/private.svg" alt="Greenkeeper badge" /></a></h1>

<p>A general-purpose utility for associating truly private state with any JavaScript object.</p>

<h2 id="installation">Installation</h2>

<p>From NPM:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install private
</code></pre></div></div>

<p>From GitHub:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd path/to/node_modules
git clone git://github.com/benjamn/private.git
cd private
npm install .
</code></pre></div></div>

<h2 id="usage">Usage</h2>
<p><strong>Get or create a secret object associated with any (non-frozen) object:</strong></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">getSecret</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"private"</span><span class="p">).</span><span class="nx">makeAccessor</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// any kind of object works</span>
<span class="nx">getSecret</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">totallySafeProperty</span> <span class="o">=</span> <span class="s2">"p455w0rd"</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> <span class="c1">// []</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> <span class="c1">// []</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getSecret</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> <span class="c1">// { totallySafeProperty: "p455w0rd" }</span>
</code></pre></div></div>
<p>Now, only code that has a reference to both <code class="highlighter-rouge">getSecret</code> and <code class="highlighter-rouge">obj</code> can possibly access <code class="highlighter-rouge">.totallySafeProperty</code>.</p>

<p><em>Importantly, no global references to the secret object are retained by the <code class="highlighter-rouge">private</code> package, so as soon as <code class="highlighter-rouge">obj</code> gets garbage collected, the secret will be reclaimed as well. In other words, you don’t have to worry about memory leaks.</em></p>

<p><strong>Create a unique property name that cannot be enumerated or guessed:</strong></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">secretKey</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"private"</span><span class="p">).</span><span class="nx">makeUniqueKey</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// any kind of object works</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">secretKey</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="p">{</span> <span class="na">totallySafeProperty</span><span class="p">:</span> <span class="s2">"p455w0rd"</span> <span class="p">},</span>
  <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span> <span class="c1">// optional; non-enumerability is the default</span>
<span class="p">});</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s2">"nonEnumerableProperty"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="s2">"anyone can guess my name"</span><span class="p">,</span>
  <span class="na">enumerable</span><span class="p">:</span> <span class="kc">false</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">secretKey</span><span class="p">].</span><span class="nx">totallySafeProperty</span><span class="p">);</span> <span class="c1">// p455w0rd</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">nonEnumerableProperty</span><span class="p">);</span> <span class="c1">// "anyone can guess my name"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> <span class="c1">// []</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span> <span class="c1">// ["nonEnumerableProperty"]</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="c1">// never called</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Because these keys are non-enumerable, you can’t discover them using a <code class="highlighter-rouge">for</code>-<code class="highlighter-rouge">in</code> loop. Because <code class="highlighter-rouge">secretKey</code> is a long string of random characters, you would have a lot of trouble guessing it. And because the <code class="highlighter-rouge">private</code> module wraps <code class="highlighter-rouge">Object.getOwnPropertyNames</code> to exclude the keys it generates, you can’t even use that interface to discover it.</p>

<p>Unless you have access to the value of the <code class="highlighter-rouge">secretKey</code> property name, there is no way to access the value associated with it. So your only responsibility as secret-keeper is to avoid handing out the value of <code class="highlighter-rouge">secretKey</code> to untrusted code.</p>

<p>Think of this style as a home-grown version of the first style. Note, however, that it requires a full implementation of ES5’s <code class="highlighter-rouge">Object.defineProperty</code> method in order to make any safety guarantees, whereas the first example will provide safety even in environments that do not support <code class="highlighter-rouge">Object.defineProperty</code>.</p>

<h2 id="rationale">Rationale</h2>

<p>In JavaScript, the only data that are truly private are local variables
whose values do not <em>leak</em> from the scope in which they were defined.</p>

<p>This notion of <em>closure privacy</em> is powerful, and it readily provides some
of the benefits of traditional data privacy, a la Java or C++:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">MyClass</span><span class="p">(</span><span class="nx">secret</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">increment</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">++</span><span class="nx">secret</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">mc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mc</span><span class="p">.</span><span class="nx">increment</span><span class="p">());</span> <span class="c1">// 4</span>
</code></pre></div></div>
<p>You can learn something about <code class="highlighter-rouge">secret</code> by calling <code class="highlighter-rouge">.increment()</code>, and you
can increase its value by one as many times as you like, but you can never
decrease its value, because it is completely inaccessible except through
the <code class="highlighter-rouge">.increment</code> method. And if the <code class="highlighter-rouge">.increment</code> method were not
available, it would be as if no <code class="highlighter-rouge">secret</code> variable had ever been declared,
as far as you could tell.</p>

<p>This style breaks down as soon as you want to inherit methods from the
prototype of a class:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">MyClass</span><span class="p">(</span><span class="nx">secret</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">secret</span> <span class="o">=</span> <span class="nx">secret</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">increment</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="nx">secret</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>The only way to communicate between the <code class="highlighter-rouge">MyClass</code> constructor and the
<code class="highlighter-rouge">.increment</code> method in this example is to manipulate shared properties of
<code class="highlighter-rouge">this</code>. Unfortunately <code class="highlighter-rouge">this.secret</code> is now exposed to unlicensed
modification:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">mc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mc</span><span class="p">.</span><span class="nx">increment</span><span class="p">());</span> <span class="c1">// 7</span>
<span class="nx">mc</span><span class="p">.</span><span class="nx">secret</span> <span class="o">-=</span> <span class="kc">Infinity</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mc</span><span class="p">.</span><span class="nx">increment</span><span class="p">());</span> <span class="c1">// -Infinity</span>
<span class="nx">mc</span><span class="p">.</span><span class="nx">secret</span> <span class="o">=</span> <span class="s2">"Go home JavaScript, you're drunk."</span><span class="p">;</span>
<span class="nx">mc</span><span class="p">.</span><span class="nx">increment</span><span class="p">();</span> <span class="c1">// NaN</span>
</code></pre></div></div>
<p>Another problem with closure privacy is that it only lends itself to
per-instance privacy, whereas the <code class="highlighter-rouge">private</code> keyword in most
object-oriented languages indicates that the data member in question is
visible to all instances of the same class.</p>

<p>Suppose you have a <code class="highlighter-rouge">Node</code> class with a notion of parents and children:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">parent</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">getParent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">parent</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">appendChild</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
        <span class="nx">child</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// Can this be made to work?</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The desire here is to allow other <code class="highlighter-rouge">Node</code> objects to manipulate the value
returned by <code class="highlighter-rouge">.getParent()</code>, but otherwise disallow any modification of the
<code class="highlighter-rouge">parent</code> variable. You could expose a <code class="highlighter-rouge">.setParent</code> function, but then
anyone could call it, and you might as well give up on the getter/setter
pattern.</p>

<p>This module solves both of these problems.</p>

<h2 id="usage-1">Usage</h2>

<p>Let’s revisit the <code class="highlighter-rouge">Node</code> example from above:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"private"</span><span class="p">).</span><span class="nx">makeAccessor</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">privates</span> <span class="o">=</span> <span class="nx">p</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">getParent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">privates</span><span class="p">.</span><span class="nx">parent</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">appendChild</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">cp</span> <span class="o">=</span> <span class="nx">p</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span>
            <span class="nx">cp</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
        <span class="nx">cp</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">child</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now, in order to access the private data of a <code class="highlighter-rouge">Node</code> object, you need to
have access to the unique <code class="highlighter-rouge">p</code> function that is being used here.  This is
already an improvement over the previous example, because it allows
restricted access by other <code class="highlighter-rouge">Node</code> instances, but can it help with the
<code class="highlighter-rouge">Node.prototype</code> problem too?</p>

<p>Yes it can!</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"private"</span><span class="p">).</span><span class="nx">makeAccessor</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">Node</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">Np</span> <span class="o">=</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

<span class="nx">Np</span><span class="p">.</span><span class="nx">getParent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">parent</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">Np</span><span class="p">.</span><span class="nx">appendChild</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">cp</span> <span class="o">=</span> <span class="nx">p</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span>
        <span class="nx">cp</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
    <span class="nx">cp</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">child</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>Because <code class="highlighter-rouge">p</code> is in scope not only within the <code class="highlighter-rouge">Node</code> constructor but also
within <code class="highlighter-rouge">Node</code> methods, we can finally avoid redefining methods every time
the <code class="highlighter-rouge">Node</code> constructor is called.</p>

<p>Now, you might be wondering how you can restrict access to <code class="highlighter-rouge">p</code> so that no
untrusted code is able to call it. The answer is to use your favorite
module pattern, be it CommonJS, AMD <code class="highlighter-rouge">define</code>, or even the old
Immediately-Invoked Function Expression:</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Node</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"private"</span><span class="p">).</span><span class="nx">makeAccessor</span><span class="p">();</span>

    <span class="kd">function</span> <span class="nx">Node</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">p</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">children</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">Np</span> <span class="o">=</span> <span class="nx">Node</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

    <span class="nx">Np</span><span class="p">.</span><span class="nx">getParent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">p</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">parent</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="nx">Np</span><span class="p">.</span><span class="nx">appendChild</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">p</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">cp</span> <span class="o">=</span> <span class="nx">p</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">cp</span><span class="p">.</span><span class="nx">parent</span><span class="p">)</span>
            <span class="nx">cp</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
        <span class="nx">cp</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">child</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">return</span> <span class="nx">Node</span><span class="p">;</span>
<span class="p">}());</span>

<span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">;</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">child</span><span class="p">);</span>
<span class="nx">assert</span><span class="p">.</span><span class="nx">strictEqual</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">getParent</span><span class="p">(),</span> <span class="nx">parent</span><span class="p">);</span>
</code></pre></div></div>
<p>Because this version of <code class="highlighter-rouge">p</code> never leaks from the enclosing function scope,
only <code class="highlighter-rouge">Node</code> objects have access to it.</p>

<p>So, you see, the claim I made at the beginning of this README remains
true:</p>

<blockquote>
  <p>In JavaScript, the only data that are truly private are local variables
whose values do not <em>leak</em> from the scope in which they were defined.</p>
</blockquote>

<p>It just so happens that closure privacy is sufficient to implement a
privacy model similar to that provided by other languages.</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
